// JavaScript
class BeforeAfterSlider extends HTMLElement {
  constructor() {
    super();
    // Find elements within the shadow DOM
    this.slider = this.querySelector('.slider');
    this.foregroundImg = this.querySelector('.foreground-img');
    this.sliderButton = this.querySelector('.slider-button');

    // Attach event listeners
    this.slider.addEventListener('input', this.handleSliderInput.bind(this));
    this.slider.addEventListener('change', this.handleSliderChange.bind(this));
    window.addEventListener('resize', this.handleSliderChange.bind(this));
  }

  handleSliderInput(e) {
    const sliderPos = e.target.value;
    // Update the width of the foreground image
    this.foregroundImg.style.width = `${sliderPos}%`;
    // Update the position of the slider button
    if(document.body.clientWidth<=600){
      this.sliderButton.style.left = `calc(${sliderPos}% - 16px)`;
    }
    else{
      this.sliderButton.style.left = `calc(${sliderPos}% - 31px)`;
    }
  }

  handleSliderChange(e) {
    // Handle slider change (if needed)
  }
}

customElements.define('before-after-slider', BeforeAfterSlider);



class BeforeAfterSliderContainer extends HTMLElement {
  constructor() {
    super();
    this.items=this.querySelectorAll('before-after-slider')
    const loadSlides = (event) => {
      let izSelected = false
      this.items.forEach(item => {
        item.removeAttribute('is-active-slide');
        if(item.getAttribute('data-id') == String(event.detail.variant.id)){
          izSelected=true
          item.setAttribute('is-active-slide',true)
        }
        else if (item.getAttribute('data-id')=='default' && !izSelected ){
          item.setAttribute('is-active-slide',true)
        }
      });
    }

    document.addEventListener('shapes:product:variantchange', loadSlides);
  }

  

  handleSliderChange(e) {
    // Handle slider change (if needed)
  }
}

customElements.define('before-after-slider-container', BeforeAfterSliderContainer);

class ImageWithTextOptions extends HTMLElement {
  constructor() {
    super();
    this.items=this.querySelectorAll('.btn-option-item')


    const handleClick = (e) => {
      const elements = document.querySelector(`.variant-input input[name*="__main-options[Color]"][value="${e.target.closest('.btn-option-item').getAttribute('title')}"]`);
      if(elements){
        const event = new Event("change");
        elements.checked = true
        elements.dispatchEvent(event);

        //trigger click
        elements.click();
      }      
    }


    const checkAvailibility = (event) => {
      
      this.items.forEach(color_option => {
        color_option.setAttribute('available-option',false)
        
        const filtred_items = theme.product_options.filter(item => {
          return item.options.some(item => item === event.detail.option)   
        })
        if(filtred_items.length!=0){
          const colors = filtred_items.filter(item => {
            return item.options.some(item => item === color_option.getAttribute('title'))   
          })
          if(colors.length!=0){
            color_option.setAttribute('available-option',true)
          }
        }
      });
    }

    const setActiveOption = (event) => {
      this.querySelector('.current-option-name').innerHTML="Default"
      this.items.forEach(color_option => {
        color_option.setAttribute('checked-option',false)
        const filtred_items = theme.product_options.filter(item => {
          return item.title == event.detail.variant 
        })
        if(filtred_items){
          const colors = filtred_items.filter(item => {
            return item.options.some(item => item === color_option.getAttribute('title'))  
          })
          if(colors.length){
            color_option.setAttribute('checked-option',true)
            
            //set option title
            this.querySelector('.current-option-name').innerHTML=color_option.getAttribute('title')
          }
        }
      });
    }

    const clearAllChecks = (event) => {
      this.items.forEach(color_option => {
        color_option.setAttribute('available-option',false)
      })
    }

    this.items.forEach(function(element) {
      element.addEventListener('click', handleClick);
    });

    window.addEventListener('shapes:product:variantactive', setActiveOption);
    window.addEventListener('shapes:product:variantavailibility', checkAvailibility);
    window.addEventListener('shapes:product:clearAllchecks', clearAllChecks);
  }

}


customElements.define('image-with-text-options', ImageWithTextOptions);

class ScrollContainer extends HTMLElement {
  constructor() {
    super();
  }

  connectedCallback() {
    const container = this.querySelector(".inner_container_items");
    const leftButton = this.querySelector(".left-button");
    const rightButton = this.querySelector(".right-button");

    // Add a 'slide-directly-edge' attribute and check its value
    const slideDirectlyEdge = this.hasAttribute("slide-directly-edge");

    const updateButtonVisibility = () => {
      // Show/hide the left button based on scroll position
      if (container.scrollLeft > 0 && leftButton) {
        leftButton.style.visibility = "visible";
      } else if (leftButton) {
        leftButton.style.visibility = "hidden";
      }
      // Show/hide the right button based on scroll position
      if (
        container.scrollLeft <
          container.scrollWidth - container.clientWidth - 10 &&
        rightButton
      ) {
        rightButton.style.visibility = "visible";
      } else if (rightButton) {
        rightButton.style.visibility = "hidden";
      }
    };

    const scrollHandler = () => {
      updateButtonVisibility();
    };

    const resizeHandler = () => {
      updateButtonVisibility();
    };

    leftButton?.addEventListener("click", () => {
      if (slideDirectlyEdge) {
        container.scrollLeft = 0; // Scroll to the left edge
      } else {
        container.scrollLeft -= 300; // Normal scrolling
      }
    });

    rightButton?.addEventListener("click", () => {
      if (slideDirectlyEdge) {
        container.scrollLeft = container.scrollWidth - container.clientWidth; // Scroll to the right edge
      } else {
        container.scrollLeft += 300; // Normal scrolling
      }
    });

    container?.addEventListener("scroll", scrollHandler);
    window.addEventListener("resize", resizeHandler);

    updateButtonVisibility(); // Trigger initial visibility check

    // Add an event listener for the refresh scroll
    this.addEventListener("slider-scroll:refresh", updateButtonVisibility);
  }
}

customElements.define("scroll-wrapper-slider", ScrollContainer);